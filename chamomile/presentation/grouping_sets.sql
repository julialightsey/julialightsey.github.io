/*
	All content is licensed as [chamomile] (http://www.chamomilesql.com/source/license.html) and  
	copyright Katherine Elizabeth Lightsey (http://www.kelightsey.com/), 1959-2015 (aka; my life), all rights reserved, 
	and as open source under the GNU Affero GPL (http://www.gnu.org/licenses/agpl-3.0.html).
	---------------------------------------------

	--
	--	description
	---------------------------------------------
		The GROUPING SETS operator can generate the same result set as that generated by using a simple GROUP BY, ROLLUP,  
			or CUBE operator. When all the groupings that are generated by using a full ROLLUP or CUBE operator are not required,  
			you can use GROUPING SETS to specify only the groupings that you want. The GROUPING SETS list can contain duplicate  
			groupings; and, when GROUPING SETS is used with ROLLUP and CUBE, it might generate duplicate groupings. Duplicate  
			groupings are retained as they would be by using UNION ALL. 
		A GROUP BY clause that uses GROUPING SETS can generate a result set equvalent to that generated by a UNION ALL of  
			multiple simple GROUP BY clauses. GROUPING SETS can generate a result equivalent to that generated by a simple  
			GROUP BY, ROLLUP or CUBE operation. Different combinations of GROUPING SETS, ROLLUP, or CUBE can generate  
			equivalent result sets. 
		Specifying GROUPING SETS ( [,...n ]) as the GROUP BY list is equivalent to a UNION ALL of queries, each  
			with one of the grouping sets as its GROUP BY list. Aggregates on floating-point numbers might return slightly  
			different results. 
		Specifies multiple groupings of data in one query. Only the specified groups are aggregated instead of the full set  
			of aggregations that are generated by CUBE or ROLLUP. The results are the equivalent of UNION ALL of the specified  
			groups. GROUPING SETS can contain a single element or a list of elements. GROUPING SETS can specify groupings  
			equivalent to those returned by ROLLUP or CUBE. The  can contain ROLLUP or CUBE. 

	--
	--	notes
	---------------------------------------------
		this presentation is designed to be run incrementally a code block at a time. 
		code blocks are delineated as:

		--
		-- code block begin
		-----------------------------------------
			<run code here>
		-----------------------------------------
		-- code block end
		--
	
	--
	-- references
	---------------------------------------------
		GROUPING SETS in SQL Server 2008 - http://blogs.msdn.com/b/craigfr/archive/2007/10/11/grouping-sets-in-sql-server-2008.aspx
		GROUPING SETS Equivalents - http://technet.microsoft.com/en-us/library/bb510427(v=sql.105).aspx
		Using GROUP BY with ROLLUP, CUBE, and GROUPING SETS - http://technet.microsoft.com/en-us/library/bb522495(v=sql.105).aspx
		GROUP BY (Transact-SQL): http://msdn.microsoft.com/en-us/library/ms177673(v=sql.110).aspx 

*/
--
-- code block begin
-------------------------------------------------
if object_id(N'tempdb..##flowers'
             , N'U') is not null
  drop table ##flowers;

go

create table ##flowers
  (
     [id]       [int] identity(1, 1)
     , [flower] [sysname]
     , [color]  [sysname]
     , [date]   [date]
     , [sales]  [money]
  );

go

insert into ##flowers
            ([flower],
             [color],
             [date],
             [sales])
values      (N'tulip',
             N'red',
             N'2005-01-01',
             12589),
            (N'tulip',
             N'red',
             N'2006-02-01',
             85456),
            (N'tulip',
             N'red',
             N'2007-03-01',
             32598),
            (N'tulip',
             N'white',
             N'2008-04-01',
             54946),
            (N'tulip',
             N'white',
             N'2009-05-01',
             38746),
            (N'lily',
             N'red',
             N'2005-01-01',
             18000),
            (N'lily',
             N'red',
             N'2006-02-01',
             65231),
            (N'lily',
             N'red',
             N'2007-03-01',
             87325),
            (N'lily',
             N'red',
             N'2008-04-01',
             35687),
            (N'petunia',
             N'white',
             N'2005-01-01',
             25000),
            (N'petunia',
             N'red',
             N'2006-02-01',
             25765),
            (N'petunia',
             N'green',
             N'2007-03-01',
             33256),
            (N'petunia',
             N'orange',
             N'2008-04-01',
             64125);

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- count for distinct flower and color
-------------------------------------------------
with [grouper]
     as (select case
                  when [flower] is null then N'total'
                  else [flower]
                end        as [flower]
                , case
                    when [color] is null then 'total'
                    else [color]
                  end      as [color]
                , count(*) as [count]
         from   ##flowers
         group  by grouping sets (( [flower], [color] ))),
     [count_distinct]
     as (select [flower]  as [flower]
                , [color] as [color]
                , [count] as [non_distinct_count]
         from   [grouper]
         where  [count] > 1)
--
select [flower]               as [flower]
       , [color]              as [color]
       , [non_distinct_count] as [non_distinct_count]
       , null                 as [grand_total_non_distinct_count]
from   [count_distinct]
union
select N'total'
       , null
       , null
       , count(*) as [count]
from   [count_distinct];

--
-- code block begin
-------------------------------------------------
--
-- get a random data set
-------------------------------------------------
-------------------------------------------------
declare @flower [sysname],
        @color  [sysname];

with [get_record_list]
     as (select top (100) [flower]  as [flower]
                          , [color] as [color]
         from   ##flowers
         group  by grouping sets (( [flower], [color] ))),
     [get_random_record]
     as (select top (1) [flower]
                        , [color]
         from   [get_record_list]
         order  by newid())
select @flower = [flower]
       , @color = [color]
from   [get_random_record];

select @flower  as [flower]
       , @color as [color];

-------------------------------------------------
-- code block end
--
--
--
-- code block begin
-------------------------------------------------
-- 
-- GROUPING SETS return the same sets as WITH CUBE and WITH ROLLUP but with more flexibility 
-- 
-- Returns totals by flower and grand total 
-------------------------------------------------
-------------------------------------------------
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
from   ##flowers
group  by rollup ( [flower], year([date]) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Same as GROUP  BY ROLLUP 
-- Returns totals by flower and grand total 
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
       , count(*)     as [count]
from   ##flowers
group  by grouping sets ( ( [flower], year([date]) ), ( [flower] ), ( ) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Returns totals by flower and totals by flower by date and grand total 
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
from   ##flowers
group  by cube ( [flower], year([date]) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Same as GROUP  BY CUBE 
-- Returns totals by flower and totals by flower by date and grand total 
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
from   ##flowers
group  by grouping sets ( ( [flower], year([date]) ), ( year([date]) ), ( [flower] ), ( ) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Same as GROUP  BY ROLLUP but without grand total 
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
from   ##flowers
group  by grouping sets ( ( [flower], year([date]) ), ( [flower] ) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Just the grand total 
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
from   ##flowers
group  by grouping sets ( ( [flower], year([date]) ), ( ) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Totals for each year and totals for each flower 
select case
         when [flower] is null then N'TOTAL'
         else [flower]
       end
       , case
           when year([date]) is null then 'TOTAL'
           else cast(year([date]) as [sysname])
         end          as [year]
       , sum([sales]) as [sales]
from   ##flowers
group  by grouping sets ( ( [flower] ), ( year([date]) ) );

-------------------------------------------------
-- code block end
--
--
-- code block begin
-------------------------------------------------
-- 
-- Returns totals by month and by year 
select case
         when [flower] is null then N'Total For '
                                    + datename(month, dateadd(month, month([date]), 0) - 1)
         else [flower]
       end            as [flower]
       , case
           when year([date]) is null then 'All Years'
           else cast(year([date]) as [sysname])
         end          as [year]
       , case
           when month([date]) is null then 'All Months'
           else cast(month([date]) as [sysname])
         end          as [month]
       , sum([sales]) as [sales]
from   ##flowers
group  by grouping sets ( ( year([date]) ), ( month([date]), ( [flower] ) ), ( month([date]) ) );
-------------------------------------------------
-- code block end
--
